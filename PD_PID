#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import PoseStamped
import time
import numpy as np
import math
import scipy.io
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio

from adafruit_pca9685 import PCA9685

# --- Importaciones adicionales para la entrada de usuario no bloqueante ---
import sys
import select
# --------------------------------------------------------------------------

# --- 1. CONFIGURACI칍N E INICIALIZACI칍N DE HARDWARE Y ROS ---

# Create the I2C bus interface.
i2c_bus = busio.I2C(SCL, SDA)

# Create a simple PCA9685 class instance.
pca = PCA9685(i2c_bus)

# Set the PWM frequency to 1000hz.
pca.frequency = 1000

# Pines BCM
in11 = 23
in12 = 22
in31 = 27
in32 = 18
in41 = 17
in42 = 4

# BCM Pin Mode
GPIO.setmode(GPIO.BCM)

# Motor Pin Configurations
GPIO.setup(in11,GPIO.OUT)
GPIO.setup(in12,GPIO.OUT)
GPIO.setup(in31,GPIO.OUT)
GPIO.setup(in32,GPIO.OUT)
GPIO.setup(in41,GPIO.OUT)
GPIO.setup(in42,GPIO.OUT)

# --- 2. VARIABLES GLOBALES DE ESTADO Y DATOS ---

mvol = 12 

# Position Variable (actualizada por OptiTrack)
p_x = 0.0
p_y = 0.0
p_z = 0.0 # Yaw angle (raw, in [-pi, pi])

# NUEVAS VARIABLES GLOBALES PARA MANEJAR EL YAW
p_z_prev = 0.0 # Almacena el yaw anterior (raw) para el c치lculo de unwrapped
p_z_unwrapped = 0.0 # Yaw acumulado que no salta 2*pi (AHORA SEGUIR츼 A p_z DIRECTAMENTE)
last_callback_time = 0.0 # Para ayudar a inicializar el unwrapped_yaw

# Para el registro de tiempo
timestamps = []
start_global_time = time.time() # Tiempo de inicio global del script

# Variables globales para las ganancias
global_Kpo_val = 0.0
global_Kdo_val = 0.0

# --- 3. FUNCIONES DE MOTOR, ORIENTACI칍N Y CALLBACK DE OPTITRACK ---

def set_motor_pwm(motor_id, channel, speed_voltage):
    """
    Asigna direcci칩n (GPIO) y velocidad (PWM) a un motor.
    """
    velocity_pwm = (np.abs(speed_voltage) * 65535) // 12 
    pwm_val = int(min(velocity_pwm, 65535))

    if motor_id == 1: # Motor 1 (Canal 0) - usa in11, in12
        if speed_voltage >= 0:
            GPIO.output(in11, False)
            GPIO.output(in12, True)
        else: # speed_voltage < 0
            GPIO.output(in11, True)
            GPIO.output(in12, False)
    elif motor_id == 2: # Motor 2 (Canal 2) - usa in31, in32
        if speed_voltage >= 0:
            GPIO.output(in31, True) # Invertido respecto a Motor 1
            GPIO.output(in32, False) # Invertido respecto a Motor 1
        else: # speed_voltage < 0
            GPIO.output(in31, False)
            GPIO.output(in32, True)
    elif motor_id == 3: # Motor 3 (Canal 3) - usa in41, in42
        if speed_voltage >= 0:
            GPIO.output(in41, True) # Invertido respecto a Motor 1
            GPIO.output(in42, False) # Invertido respecto a Motor 1
        else: # speed_voltage < 0
            GPIO.output(in41, False)
            GPIO.output(in42, True)
    else:
        rospy.logwarn(f"Advertencia: Motor ID {motor_id} no reconocido. Deteniendo motor.")
        pca.channels[channel].duty_cycle = 0
        return
        
    pca.channels[channel].duty_cycle = pwm_val

def get_yaw_from_quaternion(q_x, q_y, q_z, q_w):
    t3 = 2*(q_w*q_z+q_x*q_y)
    t4 = 1-2*(q_y*q_y+q_z*q_z)
    yaw_z = math.atan2(t3,t4)
    return yaw_z

# --- Funciones de utilidad para el manejo de 치ngulos ---
def wrap_angle(angle):
    """
    Normaliza un 치ngulo al rango [-pi, pi].
    """
    return (angle + np.pi) % (2 * np.pi) - np.pi

def shortest_angular_distance(from_angle, to_angle):
    """
    Calcula la distancia angular m치s corta de from_angle a to_angle,
    en el rango [-pi, pi].
    """
    diff = wrap_angle(to_angle - from_angle)
    return diff

def callback(data):
    global p_x, p_y, p_z, p_z_prev, p_z_unwrapped, last_callback_time

    current_callback_time = time.time()

    p_x = -data.pose.position.z
    p_y = -data.pose.position.x
    q_x = data.pose.orientation.x
    q_y = data.pose.orientation.y
    q_z = data.pose.orientation.z
    q_w = data.pose.orientation.w
    
    current_raw_yaw = get_yaw_from_quaternion(q_x, q_y, q_z, q_w)
    
    # --- COMENTADO: L칩gica para "desenvolver" el yaw para que no se reinicie ---
    # if last_callback_time != 0.0:
    #     yaw_diff = current_raw_yaw - p_z_prev

    #     # Normalizar yaw_diff para que est칠 en [-pi, pi]
    #     if yaw_diff > np.pi:
    #         yaw_diff -= 2 * np.pi
    #     elif yaw_diff < -np.pi:
    #         yaw_diff += 2 * np.pi
        
    #     p_z_unwrapped += yaw_diff
    # else:
    #     # Inicializar p_z_unwrapped con el primer yaw recibido
    #     p_z_unwrapped = current_raw_yaw
    # --------------------------------------------------------------------------
    
    # Si la l칩gica de unwrapping est치 comentada, p_z_unwrapped simplemente seguir치 a p_z
    p_z_unwrapped = current_raw_yaw # p_z_unwrapped ahora es simplemente el yaw raw
    p_z = current_raw_yaw # p_z se mantiene como el yaw en [-pi, pi]
    p_z_prev = current_raw_yaw
    last_callback_time = current_callback_time

# --- 4. BUCLE PRINCIPAL DE CONTROL main_loop ---

def main_loop():
    global p_x, p_y, p_z, p_z_unwrapped, start_global_time, global_Kpo_val, global_Kdo_val

    # 1. Par치metros del sistema 
    mR=1.99
    mR1=0.29
    IRz=6.0848e-2
    IRy1=3.24e-4
    IRz1=4.69e-4
    r=0.05 
    Jm=5.7e-7
    kb=0.01336e-3 
    ka=0.0134
    Ra=1.9
    kv=0.0001 
    re= 64 
    L=.11

    # Matrices din치micas
    E=-(1/r)*np.array([
        [np.sqrt(3)/2, -1/2, -L],
        [0, 1, -L],
        [-np.sqrt(3)/2, -1/2, -L]
    ]).T 

    B = -np.array([[0, -1, 0],
                  [1, 0, 0],
                  [0, 0, 0]])

    mR11 = mR + 3 * mR1
    mR33 = 3 * mR1 * L**2 + IRz + 3 * IRz1
    MR= np.array([[mR11,0,0],[0,mR11,0],[0,0,mR33]])

    M=MR+((IRy1+Jm*re**2)*(E.T @ E)) # E.T es la transpuesta de E
    D=re**2*(ka*kb/Ra+kv)*(E.T @ E)
    G = np.linalg.inv(M)

    # Simulation variables
    dura = 50 # Simulation length in seconds
    h = 0.006 # Step size 
    t = np.arange(0,dura+h,h) # Time variable
    j = int(np.size(t)) # Size of time vector
    ite = np.arange(0,j,1)
    
    # States initialization
    x = np.zeros((3,j+1)) # Position (Medida por OptiTrack)
    xp = np.zeros((3,j+1)) # Velocity (estimada directamente)
    
    # Desired trajectory 
    xd = np.zeros((3,j)) # Desired position
    xdp = np.zeros((3,j)) # Desired velocity
    xdpp = np.zeros((3,j)) # Desired acceleration
    
    # --- Trayectoria deseada fuera del bucle for ---
    a  = 0.5                        #Signal aplitud x and y
    w1  = 2*math.pi*0.05           #Velocity for x and y
    w2 = 0.5*math.pi*0.05         #Angular velocity for angle theta
    xd[0] =a*np.sin(w1*t)
    xd[1] =a*np.cos(w1*t)
    xd[2] =-w2*t
        
    xdp[0] =a*w1*np.cos(w1*t)
    xdp[1] =-a*w1*np.sin(w1*t)
    xdp[2] =-w2
        
    xdpp[0] =-a*w1*w1*np.sin(w1*t)
    xdpp[1] =-a*w1*w1*np.cos(w1*t)
    xdpp[2] = 0
    # -----------------------------------------------

    # Errors
    e = np.zeros((3,j)) # Tracking error position
    ep = np.zeros((3,j)) # Tracking error velocity (respecto a la velocidad real estimada)
    ei = np.zeros((3,j + 1)) 

    # Inicializaci칩n matrices R, C, F
    R_mat = np.zeros((3,3,j)) # Renombrado a R_mat para evitar conflicto con RPi.GPIO
    C = np.zeros((3,3,j))
    F = np.zeros((3,j))

    # Initializing control variables
    tau = np.zeros((3,j)) # Computed torque
    u = np.zeros((3,j)) # Motor voltages

    # Par치metros de la trayectoria sinusoidal (solo para referencia en logs, ya generada arriba)
    amplitude_x = 0.5  # Amplitud en metros para eje X
    amplitude_y = 0.3  # Amplitud en metros para eje Y
    frequency = 0.2    # Frecuencia en Hz
    omega = 2 * np.pi * frequency  # Frecuencia angular

    #Ganancias Orientacion obtenidas en 
    Ki_th = -3.15#Kth[0, 0]
    Kp_th = -6.75#Kth[0, 1]
    Kd_th = -4.6 #Kth[0, 2]

    # Ganancias del controlador (Usando los valores ingresados por el usuario)
    Kpo = global_Kpo_val * np.eye(2)
    Kdo = global_Kdo_val * np.eye(2)
    
    rospy.loginfo(f"Ganancias Kpo: \n{Kpo}\nGanancias Kdo: \n{Kdo}")
    rospy.loginfo(f"Trayectoria sinusoidal: A_x={amplitude_x}m, A_y={amplitude_y}m, f={frequency}Hz")

    rospy.loginfo("Iniciando bucle de control con trayectoria sinusoidal...")
    rate = rospy.Rate(1/h) # h es el paso de tiempo, 1/h es la frecuencia en Hz

    for i in ite:
        if rospy.is_shutdown():
            break

        # Tiempo actual para la trayectoria
        current_time = t[i]
        
        # 1. Leer la posici칩n actual de OptiTrack
        x[0][i] = p_x
        x[1][i] = p_y
        x[2][i] = p_z_unwrapped # 춰Usamos el yaw desenvuelto aqu칤 (o raw si el unwrapping est치 comentado)!

        # 2. Estimaci칩n de velocidad actual (derivando la posici칩n)
        if i > 0:
            xp[:,i] = (x[:,i] - x[:,i-1]) / h
        else:
            xp[:,i] = np.array([0.0, 0.0, 0.0]) # Velocidad inicial cero


        # 4. Calcular errores de seguimiento (posici칩n y velocidad)
        e[0,i] = xd[0,i] - x[0,i]
        e[1,i] = xd[1,i] - x[1,i]
        # ERROR DE ORIENTACI칍N: Usar nuestra funci칩n shortest_angular_distance para el yaw
        e[2,i] = shortest_angular_distance(x[2,i], xd[2][i]) 
        
        ei[:, i+1] = ei[:, i] + h * e[:, i] 
        ep[:,i] = xdp[:,i] - xp[:,i]

        #errores x,y
        em = e[:2, i].reshape(2, 1) 
        epm = ep[:2, i].reshape(2, 1) 

        # 5. Matrices necesarias para el control (usan x[2][i] para orientaci칩n actual, xp[2][i] para velocidad angular)
        R_mat[:,:,i]= [[ math.cos(x[2][i]) , math.sin(x[2][i]) , 0],
                       [-math.sin(x[2][i]) , math.cos(x[2][i]) , 0],
                       [ 0 , 0 , 1]]

        C[:,:,i]= 2/(r**2)*(IRy1+Jm*re**2)*xp[2][i]*B 
        F[:,i]=-np.linalg.inv(M) @ ((C[:,:,i]+D) @ xp[:,i]) # El @ es para multiplicaci칩n de matrices en numpy
        
        c_d = 0.0 # Constant perturbation, 
        um = Kpo @ em + Kdo @ epm
        uth = Ki_th * ei[2, i+1] + Kp_th * e[2, i] + Kd_th * ep[2, i]
        # 6. Controlador 
        u2 = np.array([um[0, 0], um[1, 0], uth])
        
        # C치lculo de tau (torque)
        tau[0,i] = -(1/G[0,0]) * (F[0,i] - xdpp[0,i] + u2[0] + c_d)
        tau[1,i] = -(1/G[1,1]) * (F[1,i] - xdpp[1,i] + u2[1] + c_d)
        tau[2,i] = -(1/G[2,2]) * (F[2,i] - xdpp[2][i] + u2[2] + c_d)

        # 7. Conversi칩n de Torque/Fuerza (tau) a Voltajes de Motor (u)
        u[:,i] = (Ra/(ka*re)) * np.linalg.inv(E) @ np.linalg.inv(R_mat[:,:,i].T) @ tau[:,i]

        # 8. Saturaci칩n de Voltajes de Motor y Env칤o a PWM
        u11 = round(u[0,i],2)
        u22 = round(u[1,i],2)
        u33 = round(u[2,i],2)

        if np.abs(u11) > mvol:
            u11 = mvol*np.sign(u11)
        if np.abs(u22) > mvol:
            u22 = mvol*np.sign(u22)
        if np.abs(u33) > mvol:
            u33 = mvol*np.sign(u33)
        
        set_motor_pwm(1, 0, u11)
        set_motor_pwm(2, 2, u22)
        set_motor_pwm(3, 3, u33)
        
        # La salida de log detallada durante el control est치 deshabilitada
        rate.sleep()

    rospy.loginfo("Bucle de control finalizado.")

    # --- 5. Guardado de Datos ---
    
    scipy.io.savemat('datos_robot_sinusoidal_control.mat', {
        'time_vec': t,
        'xd': xd[:, :j],
        'x_opti': x[:, :j], # Posici칩n real medida por OptiTrack (yaw desenvuelto o raw)
        'p_z_raw': p_z, # Puedes guardar el yaw raw tambi칠n si quieres analizarlo
        'xp_est_direct': xp[:, :j], # Velocidad estimada directamente
        'e_pos_track': e, # Error de seguimiento de posici칩n
        'e_vel_track': ep, # Error de seguimiento de velocidad
        'u_voltajes': u[:, :j], # Voltajes de control
        'tau_torque': tau, # Torque calculado
        'F_term': F,
        'R_rot_mat': R_mat
    })
    rospy.loginfo("Datos completos guardados en datos_robot_sinusoidal_control.mat")

# --- Funci칩n para detener todos los motores ---
def stop_motors():
    rospy.loginfo("Deteniendo motores...")
    pca.channels[0].duty_cycle = 0
    pca.channels[2].duty_cycle = 0
    pca.channels[3].duty_cycle = 0
    GPIO.output(in11, False)
    GPIO.output(in12, False)
    GPIO.output(in31, False)
    GPIO.output(in32, False)
    GPIO.output(in41, False)
    GPIO.output(in42, False)

# --- 6. INICIO DEL NODO ROS Y EJECUCI칍N DEL BUCLE PRINCIPAL ---

if __name__ == "__main__":
    rospy.init_node("control_robot_omnidireccional_sinusoidal_control")
    rospy.Subscriber("vrpn_client_node/RB1/pose", PoseStamped, callback)

    rospy.loginfo("Esperando datos de OptiTrack para inicializar...")
    timeout_start = time.time()
    # Esperar hasta que se reciban los primeros datos de OptiTrack
    while (time.time() - timeout_start < 10) and (last_callback_time == 0.0) and not rospy.is_shutdown():
        time.sleep(0.1)
    
    if (last_callback_time == 0.0):
        rospy.logerr("ERROR: No se recibieron datos de OptiTrack. Aseg칰rate de que el VRPN est칠 funcionando y el tema sea correcto.")
        GPIO.cleanup() 
    else:
        rospy.loginfo(f"춰Datos de OptiTrack recibidos!")
        rospy.loginfo(f"La trayectoria deseada tiene una orientaci칩n final de 0.0 radianes.")
        rospy.loginfo(f"Por favor, ajuste manualmente el robot para que su orientaci칩n sea cercana a 0.0 rad.")
        rospy.loginfo(f"La orientaci칩n actual se actualizar치 cada 3 segundos. Pulsa Enter para continuar con el control.")
        
        # Bucle para mostrar la orientaci칩n cada 3 segundos hasta que se presione Enter
        last_display_time = time.time()
        # Configurar stdin para no bloquear
        import termios, tty
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            while not rospy.is_shutdown():
                if (time.time() - last_display_time) >= 3.0:
                    rospy.loginfo(f"Orientaci칩n actual del robot (Yaw, en radianes [-pi, pi]): {p_z:.3f}")
                    last_display_time = time.time()
                
                # Comprobar si hay entrada (una pulsaci칩n de tecla, no solo Enter)
                if select.select([sys.stdin], [], [], 0)[0]:
                    char = sys.stdin.read(1) # Lee un solo car치cter
                    if char == '\n' or char == '\r': # Si se presiona Enter
                        break
                
                time.sleep(0.1) # Peque침a pausa para no saturar la CPU
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
            # Imprime una nueva l칤nea despu칠s de salir del modo raw para que la terminal se vea bien
            print("\r\n", end="") 


        # Solicitar las ganancias al usuario
        while True:
            try:
                input_kpo = input("Introduce el valor para Kpo_val (ej. 2.5): ")
                global_Kpo_val = float(input_kpo)
                break
            except ValueError:
                print("Entrada inv치lida. Por favor, introduce un n칰mero.")
        
        while True:
            try:
                input_kdo = input("Introduce el valor para Kdo_val (ej. 2.5): ")
                global_Kdo_val = float(input_kdo)
                break
            except ValueError:
                print("Entrada inv치lida. Por favor, introduce un n칰mero.")

        time.sleep(1.0) # Peque침a pausa adicional antes de iniciar el control

        try:
            main_loop()
        except rospy.ROSInterruptException:
            rospy.loginfo("ROS interrupci칩n detectada. Deteniendo el control.")
        finally:
            stop_motors()
            GPIO.cleanup()
            rospy.loginfo("Programa finalizado y motores detenidos. 춰Adi칩s! 游녦")
