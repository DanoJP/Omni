#!/usr/bin/env python3

import rospy
from geometry_msgs.msg import PoseStamped
import time
import numpy as np
import math
import scipy.io
import RPi.GPIO as GPIO
from board import SCL, SDA
import busio

from adafruit_pca9685 import PCA9685
 

# --- 1. CONFIGURACIN E INICIALIZACIN DE HARDWARE Y ROS ---

# Create the I2C bus interface.
i2c_bus = busio.I2C(SCL, SDA)

# Create a simple PCA9685 class instance.
pca = PCA9685(i2c_bus)

# Set the PWM frequency to 1000hz.
pca.frequency = 1000

# Pines BCM
in11 = 23
in12 = 22
in31 = 27
in32 = 18
in41 = 17
in42 = 4

# BCM Pin Mode
GPIO.setmode(GPIO.BCM)

# Motor Pin Configurations
GPIO.setup(in11,GPIO.OUT)
GPIO.setup(in12,GPIO.OUT)
GPIO.setup(in31,GPIO.OUT)
GPIO.setup(in32,GPIO.OUT)
GPIO.setup(in41,GPIO.OUT)
GPIO.setup(in42,GPIO.OUT)

# --- 2. VARIABLES GLOBALES DE ESTADO Y DATOS ---

mvol = 12 

# Position Variable (actualizada por OptiTrack)
p_x = 0.0
p_y = 0.0
p_z = 0.0 # Yaw angle (raw, in [-pi, pi])

# NUEVAS VARIABLES GLOBALES PARA MANEJAR EL YAW
p_z_prev = 0.0 # Almacena el yaw anterior (raw) para el c谩lculo de unwrapped
p_z_unwrapped = 0.0 # Yaw acumulado que no salta 2*pi
last_callback_time = 0.0 # Para ayudar a inicializar el unwrapped_yaw

# Para el registro de tiempo
timestamps = []
start_global_time = time.time() # Tiempo de inicio global del script

# Variables globales para las ganancias
global_Kpo_val = 0.0
global_Kdo_val = 0.0

# --- 3. FUNCIONES DE MOTOR, ORIENTACIN Y CALLBACK DE OPTITRACK ---

def set_motor_pwm(motor_id, channel, speed_voltage):
    """
    Asigna direcci贸n (GPIO) y velocidad (PWM) a un motor.
    """
    velocity_pwm = (np.abs(speed_voltage) * 65535) // 12 
    pwm_val = int(min(velocity_pwm, 65535))

    if motor_id == 1: # Motor 1 (Canal 0) - usa in11, in12
        if speed_voltage >= 0:
            GPIO.output(in11, False)
            GPIO.output(in12, True)
        else: # speed_voltage < 0
            GPIO.output(in11, True)
            GPIO.output(in12, False)
    elif motor_id == 2: # Motor 2 (Canal 2) - usa in31, in32
        if speed_voltage >= 0:
            GPIO.output(in31, True) # Invertido respecto a Motor 1
            GPIO.output(in32, False) # Invertido respecto a Motor 1
        else: # speed_voltage < 0
            GPIO.output(in31, False)
            GPIO.output(in32, True)
    elif motor_id == 3: # Motor 3 (Canal 3) - usa in41, in42
        if speed_voltage >= 0:
            GPIO.output(in41, True) # Invertido respecto a Motor 1
            GPIO.output(in42, False) # Invertido respecto a Motor 1
        else: # speed_voltage < 0
            GPIO.output(in41, False)
            GPIO.output(in42, True)
    else:
        rospy.logwarn(f"Advertencia: Motor ID {motor_id} no reconocido. Deteniendo motor.")
        pca.channels[channel].duty_cycle = 0
        return
        
    pca.channels[channel].duty_cycle = pwm_val

def get_yaw_from_quaternion(q_x, q_y, q_z, q_w):
    t3 = 2*(q_w*q_z+q_x*q_y)
    t4 = 1-2*(q_y*q_y+q_z*q_z)
    yaw_z = math.atan2(t3,t4)
    return yaw_z

# --- Funciones de utilidad para el manejo de 谩ngulos ---
def wrap_angle(angle):
    """
    Normaliza un 谩ngulo al rango [-pi, pi].
    """
    return (angle + np.pi) % (2 * np.pi) - np.pi

def shortest_angular_distance(from_angle, to_angle):
    """
    Calcula la distancia angular m谩s corta de from_angle a to_angle,
    en el rango [-pi, pi].
    """
    diff = wrap_angle(to_angle - from_angle)
    return diff

def callback(data):
    global p_x, p_y, p_z, p_z_prev, p_z_unwrapped, last_callback_time

    current_callback_time = time.time()

    p_x = -data.pose.position.z
    p_y = -data.pose.position.x
    q_x = data.pose.orientation.x
    q_y = data.pose.orientation.y
    q_z = data.pose.orientation.z
    q_w = data.pose.orientation.w
    
    current_raw_yaw = get_yaw_from_quaternion(q_x, q_y, q_z, q_w)
    
    if last_callback_time != 0.0:
        yaw_diff = current_raw_yaw - p_z_prev

        # Normalizar yaw_diff para que est茅 en [-pi, pi]
        # Esto maneja los cruces de pi a -pi o viceversa
        if yaw_diff > np.pi:
            yaw_diff -= 2 * np.pi
        elif yaw_diff < -np.pi:
            yaw_diff += 2 * np.pi
        
        p_z_unwrapped += yaw_diff
    else:
        # Inicializar p_z_unwrapped con el primer yaw recibido
        p_z_unwrapped = current_raw_yaw
    
    p_z = current_raw_yaw # p_z se mantiene como el yaw en [-pi, pi]
    p_z_prev = current_raw_yaw
    last_callback_time = current_callback_time

# --- 4. BUCLE PRINCIPAL DE CONTROL main_loop ---

def main_loop():
    global p_x, p_y, p_z, p_z_unwrapped, start_global_time, global_Kpo_val, global_Kdo_val

    # 1. Par谩metros del sistema (de tu simulaci贸n MATLAB)
    mR=1.99
    mR1=0.29
    IRz=6.0848e-2
    IRy1=3.24e-4
    IRz1=4.69e-4
    r=0.05 
    Jm=5.7e-7
    kb=0.01336e-3 
    ka=0.0134
    Ra=1.9
    kv=0.0001 
    re= 64 
    L=.11

    # Matrices din谩micas
    E=-(1/r)*np.array([
        [np.sqrt(3)/2, -1/2, -L],
        [0, 1, -L],
        [-np.sqrt(3)/2, -1/2, -L]
    ]).T 

    B = -np.array([[0, -1, 0],
                  [1, 0, 0],
                  [0, 0, 0]])

    mR11 = mR + 3 * mR1
    mR33 = 3 * mR1 * L**2 + IRz + 3 * IRz1
    MR= np.array([[mR11,0,0],[0,mR11,0],[0,0,mR33]])

    M=MR+((IRy1+Jm*re**2)*(E.T @ E)) # E.T es la transpuesta de E
    D=re**2*(ka*kb/Ra+kv)*(E.T @ E)
    G = np.linalg.inv(M)

    # Simulation variables
    dura = 20 # Simulation length in seconds
    h = 0.006 # Step size (de tu MATLAB)
    t = np.arange(0,dura+h,h) # Time variable
    j = int(np.size(t)) # Size of time vector
    ite = np.arange(0,j,1)
    
    # States initialization
    x = np.zeros((3,j+1)) # Position (Medida por OptiTrack)
    xp = np.zeros((3,j+1)) # Velocity (estimada directamente)
    
    # Desired trajectory - ahora se calcula en tiempo real
    xd = np.zeros((3,j)) # Desired position
    xdp = np.zeros((3,j)) # Desired velocity
    xdpp = np.zeros((3,j)) # Desired acceleration
    
    # Errors
    e = np.zeros((3,j)) # Tracking error position
    ep = np.zeros((3,j)) # Tracking error velocity (respecto a la velocidad real estimada)
    ei = np.zeros((3,j + 1)) 

    # Inicializaci贸n matrices R, C, F
    R_mat = np.zeros((3,3,j)) # Renombrado a R_mat para evitar conflicto con RPi.GPIO
    C = np.zeros((3,3,j))
    F = np.zeros((3,j))

    # Initializing control variables
    tau = np.zeros((3,j)) # Computed torque
    u = np.zeros((3,j)) # Motor voltages

    # Par谩metros de la trayectoria sinusoidal
    amplitude_x = 0.5  # Amplitud en metros para eje X
    amplitude_y = 0.3  # Amplitud en metros para eje Y
    frequency = 0.2    # Frecuencia en Hz
    omega = 2 * np.pi * frequency  # Frecuencia angular

    #Ganancias Orientacion obtenidas en Matlab
    Ki_th = -3.15#Kth[0, 0]
    Kp_th = -6.75#Kth[0, 1]
    Kd_th = -4.6 #Kth[0, 2]

    # Ganancias del controlador (Usando los valores ingresados por el usuario)
    Kpo = global_Kpo_val * np.eye(2)
    Kdo = global_Kdo_val * np.eye(2)
    
    rospy.loginfo(f"Ganancias Kpo: \n{Kpo}\nGanancias Kdo: \n{Kdo}")
    rospy.loginfo(f"Trayectoria sinusoidal: A_x={amplitude_x}m, A_y={amplitude_y}m, f={frequency}Hz")

    rospy.loginfo("Iniciando bucle de control con trayectoria sinusoidal...")
    rate = rospy.Rate(1/h) # h es el paso de tiempo, 1/h es la frecuencia en Hz

    for i in ite:
        if rospy.is_shutdown():
            break

        # Tiempo actual para la trayectoria
        current_time = t[i]
        
        # 1. Leer la posici贸n actual de OptiTrack
        x[0][i] = p_x
        x[1][i] = p_y
        x[2][i] = p_z_unwrapped # 隆Usamos el yaw desenvuelto aqu铆!

        # 2. Estimaci贸n de velocidad actual (derivando la posici贸n)
        # Esto ahora es mucho m谩s estable para el yaw
        if i > 0:
            xp[:,i] = (x[:,i] - x[:,i-1]) / h
        else:
            xp[:,i] = np.array([0.0, 0.0, 0.0]) # Velocidad inicial cero

        # 3. Calcular trayectoria deseada SINUSOIDAL en tiempo real
        xd[0][i] = amplitude_x * math.sin(omega * current_time)
        xd[1][i] = amplitude_y * math.cos(omega * current_time) 
        xd[2][i] = 0.0  # Orientaci贸n deseada fija (aseg煤rate de que sea 0 o un valor constante)
        
        xdp[0][i] = amplitude_x * omega * math.cos(omega * current_time)
        xdp[1][i] = -amplitude_y * omega * math.sin(omega * current_time)
        xdp[2][i] = 0.0
        
        xdpp[0][i] = -amplitude_x * omega**2 * math.sin(omega * current_time)
        xdpp[1][i] = -amplitude_y * omega**2 * math.cos(omega * current_time)
        xdpp[2][i] = 0.0

        # 4. Calcular errores de seguimiento (posici贸n y velocidad)
        e[0,i] = xd[0,i] - x[0,i]
        e[1,i] = xd[1,i] - x[1,i]
        # ERROR DE ORIENTACIN: Usar nuestra funci贸n shortest_angular_distance para el yaw
        e[2,i] = shortest_angular_distance(x[2,i], xd[2,i]) # 隆Cambio aqu铆!
        
        ei[:, i+1] = ei[:, i] + h * e[:, i] 
        ep[:,i] = xdp[:,i] - xp[:,i]

        #errores x,y
        em = e[:2, i].reshape(2, 1) 
        epm = ep[:2, i].reshape(2, 1) 

        # 5. Matrices necesarias para el control (usan x[2][i] para orientaci贸n actual, xp[2][i] para velocidad angular)
        # R_mat sigue usando x[2][i] (que ahora es el yaw desenvuelto)
        R_mat[:,:,i]= [[ math.cos(x[2][i]) , math.sin(x[2][i]) , 0],
                       [-math.sin(x[2][i]) , math.cos(x[2][i]) , 0],
                       [ 0 , 0 , 1]]

        C[:,:,i]= 2/(r**2)*(IRy1+Jm*re**2)*xp[2][i]*B 
        F[:,i]=-np.linalg.inv(M) @ ((C[:,:,i]+D) @ xp[:,i]) # El @ es para multiplicaci贸n de matrices en numpy
        
        c_d = 0.0 # Constant perturbation, como en tu MATLAB
        um = Kpo @ em + Kdo @ epm
        uth = Ki_th * ei[2, i+1] + Kp_th * e[2, i] + Kd_th * ep[2, i]
        # 6. Controlador 
        u2 = np.array([um[0, 0], um[1, 0], uth])
        
        # C谩lculo de tau (torque)
        tau[0,i] = -(1/G[0,0]) * (F[0,i] - xdpp[0,i] + u2[0] + c_d)
        tau[1,i] = -(1/G[1,1]) * (F[1,i] - xdpp[1,i] + u2[1] + c_d)
        tau[2,i] = -(1/G[2,2]) * (F[2,i] - xdpp[2][i] + u2[2] + c_d)

        # 7. Conversi贸n de Torque/Fuerza (tau) a Voltajes de Motor (u)
        u[:,i] = (Ra/(ka*re)) * np.linalg.inv(E) @ np.linalg.inv(R_mat[:,:,i].T) @ tau[:,i]

        # 8. Saturaci贸n de Voltajes de Motor y Env铆o a PWM
        u11 = round(u[0,i],2)
        u22 = round(u[1,i],2)
        u33 = round(u[2,i],2)

        if np.abs(u11) > mvol:
            u11 = mvol*np.sign(u11)
        if np.abs(u22) > mvol:
            u22 = mvol*np.sign(u22)
        if np.abs(u33) > mvol:
            u33 = mvol*np.sign(u33)
        
        set_motor_pwm(1, 0, u11)
        set_motor_pwm(2, 2, u22)
        set_motor_pwm(3, 3, u33)
        
        # Log cada 100 iteraciones para no saturar
        if i % 100 == 0:
            rospy.loginfo(f"Tiempo: {current_time:.2f}s | Posici贸n: ({x[0][i]:.3f}, {x[1][i]:.3f}) | Orientaci贸n (desenvuelta): {x[2][i]:.3f} rad | Deseada: ({xd[0][i]:.3f}, {xd[1][i]:.3f}, {xd[2][i]:.3f} rad)")
            rospy.loginfo(f"Errores (pos, vel, yaw): ({e[0,i]:.3f}, {e[1,i]:.3f}, {e[2,i]:.3f})")

        rate.sleep()

    rospy.loginfo("Bucle de control finalizado.")

    # --- 5. Guardado de Datos ---
    
    scipy.io.savemat('datos_robot_sinusoidal_control.mat', {
        'time_vec': t,
        'xd': xd[:, :j],
        'x_opti': x[:, :j], # Posici贸n real medida por OptiTrack (yaw desenvuelto)
        'p_z_raw': p_z, # Puedes guardar el yaw raw tambi茅n si quieres analizarlo
        'xp_est_direct': xp[:, :j], # Velocidad estimada directamente
        'e_pos_track': e, # Error de seguimiento de posici贸n
        'e_vel_track': ep, # Error de seguimiento de velocidad
        'u_voltajes': u[:, :j], # Voltajes de control
        'tau_torque': tau, # Torque calculado
        'F_term': F,
        'R_rot_mat': R_mat
    })
    rospy.loginfo("Datos completos guardados en datos_robot_sinusoidal_control.mat")

# --- Funci贸n para detener todos los motores ---
def stop_motors():
    rospy.loginfo("Deteniendo motores...")
    pca.channels[0].duty_cycle = 0
    pca.channels[2].duty_cycle = 0
    pca.channels[3].duty_cycle = 0
    GPIO.output(in11, False)
    GPIO.output(in12, False)
    GPIO.output(in31, False)
    GPIO.output(in32, False)
    GPIO.output(in41, False)
    GPIO.output(in42, False)

# --- 6. INICIO DEL NODO ROS Y EJECUCIN DEL BUCLE PRINCIPAL ---

if __name__ == "__main__":
    rospy.init_node("control_robot_omnidireccional_sinusoidal_control")
    rospy.Subscriber("vrpn_client_node/RB1/pose", PoseStamped, callback)

    # Solicitar las ganancias al usuario
    while True:
        try:
            input_kpo = input("Introduce el valor para Kpo_val (ej. 2.5): ")
            global_Kpo_val = float(input_kpo)
            break
        except ValueError:
            print("Entrada inv谩lida. Por favor, introduce un n煤mero.")
    
    while True:
        try:
            input_kdo = input("Introduce el valor para Kdo_val (ej. 2.5): ")
            global_Kdo_val = float(input_kdo)
            break
        except ValueError:
            print("Entrada inv谩lida. Por favor, introduce un n煤mero.")

    rospy.loginfo("Esperando datos del VRPN para inicializar el control...")
    timeout_start = time.time()
    # Esperar hasta 10 segundos para recibir los primeros datos de OptiTrack
    # IMPORTANTE: La inicializaci贸n de p_z_unwrapped ahora ocurre en el primer callback
    while (time.time() - timeout_start < 10) and (last_callback_time == 0.0) and not rospy.is_shutdown():
        time.sleep(0.1)
    
    if (last_callback_time == 0.0):
        rospy.logerr("ERROR: No se recibieron datos de OptiTrack. Aseg煤rate de que el VRPN est茅 funcionando y el tema sea correcto.")
        GPIO.cleanup() 
    else:
        time.sleep(1.0) # Peque帽a pausa adicional despu茅s de recibir los datos

        try:
            main_loop()
        except rospy.ROSInterruptException:
            rospy.loginfo("ROS interrupci贸n detectada. Deteniendo el control.")
        finally:
            stop_motors()
            GPIO.cleanup()
            rospy.loginfo("Programa finalizado y motores detenidos. 隆Adi贸s! ")
